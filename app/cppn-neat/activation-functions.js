/**
 * Adjust activation functions inside of CPPNs
 * @param cppnjs  A reference to the cppnjs module
 */
export function setActivationFunctions( cppnjs ) {

  var waveActivationFunction = {
    sin: "sin", cos: "cos", arctan: "arctan",
    spike: "spike"
  }

  if( ! cppnjs.cppnActivationFunctions[waveActivationFunction.spike] ) {
    cppnjs.cppnActivationFunctions.AddActivationFunction(
        waveActivationFunction.spike,
        {
          functionID: waveActivationFunction.spike,
          functionString: "if(floor(x) is even) 1 - 2*(x-floor(x)) else -1 + 2*(x-floor(x))",
          functionDescription: "Basically a pointy version of sin or cos.",
          functionCalculate: function(inputSignal)
          {
              if(Math.floor(inputSignal)%2 == 0) return 1.0 - 2.0 * (inputSignal-Math.floor(inputSignal));
              else return -1.0 + 2.0 * (inputSignal-Math.floor(inputSignal));
          },
          functionEnclose: function(stringToEnclose)
          {
              return "if(Math.floor("+stringToEnclose+")%2 == 0) return 1.0 - 2.0 * ("+stringToEnclose+"-Math.floor("+stringToEnclose+"));"
              +"else return -1.0 + 2.0 * ("+stringToEnclose+"-Math.floor("+stringToEnclose+"));";
          }
      }
    );
  }

  if( ! cppnjs.cppnActivationFunctions[waveActivationFunction.sin] )  {
    cppnjs.cppnActivationFunctions.AddActivationFunction(
        waveActivationFunction.sin,
        {
          functionID: waveActivationFunction.sin,
          functionString: "sin(inputSignal)",
          functionDescription: "sin function with normal period",
          functionCalculate: function(inputSignal)
          {
              return Math.sin(inputSignal);
          },
          functionEnclose: function(stringToEnclose)
          {
              return "(Math.sin(" + stringToEnclose + "))";
          }
        }
      );
  }

  if( ! cppnjs.cppnActivationFunctions[waveActivationFunction.cos] ) {
    cppnjs.cppnActivationFunctions.AddActivationFunction(
      waveActivationFunction.cos,
      {
          functionID: waveActivationFunction.cos,
          functionString: "Cos(inputSignal)",
          functionDescription: "Cos function with normal period",
          functionCalculate: function(inputSignal)
          {
              return Math.cos(inputSignal);
          },
          functionEnclose: function(stringToEnclose)
          {
              return "(Math.cos(" + stringToEnclose + "))";
          }
        }
      );
  }

  if( ! cppnjs.cppnActivationFunctions[waveActivationFunction.arctan] ) {
    cppnjs.cppnActivationFunctions.AddActivationFunction(
      waveActivationFunction.arctan,
      {
          functionID: waveActivationFunction.arctan,
          functionString: "atan(inputSignal)",
          functionDescription:"Arc Tan with normal period",
          functionCalculate: function(inputSignal)
          {
              return Math.atan(inputSignal);
          },
          functionEnclose: function(stringToEnclose)
          {
              return "(Math.atan(" + stringToEnclose + "))";
          }
        }
      );
  }

  //makes these the only activation functions being generated by wave genotypes -- all equal probabilibty for now
  var probs = {};
  probs[waveActivationFunction.sin] = .25;
  probs[waveActivationFunction.cos] = .25;
  probs[waveActivationFunction.arctan] = .25;
  probs[waveActivationFunction.spike] = .25;

  cppnjs.cppnActivationFactory.setProbabilities(probs);
}
